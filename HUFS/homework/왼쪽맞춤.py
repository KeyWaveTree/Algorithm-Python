W = int(input()) #입력가능한 문자 갯수
words = input().split() #공백 단위로 단어들을 분리하여 리스트로 저장
n = len(words) #필요한 문서의 높이를 n이라고 하면 가장 최악의 높이 경우는 한 단어당 1줄이므로 최대 문서의 길이는 단어 갯수이다.

#단어 배치의 경우는 다음과 같다.
'''
1) W의 범위가 초과 되었을때 부분적으로 잘라 다음 줄 배치      
(단어 1)_(단어 2)  | 1줄에 단어 여러개 배치 후 다음단어가 W 있는 길이를 넘으면    
(단어 3)          |  다음줄에 배치한다.  

2) W의 범위가 초과 되었을때 대부분 잘라 다음 줄 배치 
(단어 1)          |1줄에 단어 배치 
(단어 2)_(단어_3)  |다음줄에서는 다음 단어길이 + 다음단어+1 길이가 W를 넘지 않으면 배치

1), 2)경우에서 2가지 단어뿐만이 아닌 여러가지 단어가 추가적으로 들어갈 수 있다.

3) 한 단어당 한 줄 배치 
(단어 1)          |
(단어 2)          |
(단어 3)          |
 ....                                        
 ....
 ....              
 
'''

#답이 없는 경우 최소 패널티를 무한 -  아주 큰 패널티를 준다.
#2차원 (n+1)^2 크기인 dp 테이블을 만들어 모든 칸은 최대 패널티로 초기값을 준다.
#이때 다음 라인을 부르기 편하게 페이지라고 s정의

dp = [[987654321 for _ in range(n + 1)] for _ in range(n + 1)] #dp테이블 (n+1)^2개
dp[0][0] = 0 #첫줄 dp테이블 값을 0으로 준다.
#dp테이블 [0][0] 최소 패널티를 0를 왜 사용하였는가?
# -> 최소의 비용을 계산하기 위해서는 dp[n-1(이전 페이지)][m-1(이전 페이지까지의 더한 값 최소 패널티 위치)]값을 가져와
# dp[n][m]다 저장하기 위해서이다.

for i in range(1, n + 1):
    for j in range(1, n + 1):
        l = -1 #페이지의 길이는 아무것도 없는 상태이므로 -1을 준다. - 마지막 문장의 공백값을 제외시켜주기 위해서
        for k in range(i, 0, -1):
            l += len(words[k - 1]) + 1 #공백을 포함시키기 위해서 길이+1
            #현재 페이지 최대 상한보다 단어 합친 길이가(공백포함) 더 크다면
            if l > W: break #현재 페이지 break

            # dp[i][j] = i번째 단어까지 사용한, j 페이지 채우는 최소 패널티
            # 현재 페이지의 최소 패널티는
            # 현재 저장되어있는 최소 패널티, (이전 페이지의 최소 패널티 + 지금까지 저장한 단어 패널티) 중 최소값이다.
            dp[i][j] = min(dp[i][j], dp[k - 1][j - 1] + (W - l) ** 3) #**의 연산은 log 시간이 걸림

# dp[n] = min(dp[n-1]+A[n], .. (여러경우)..) #n-1까지 더한 최소값과 지금 줄의 값을 더한다.
print(min(dp[n])) #N개 까지 단어를 사용했을때 최소 패널티
# 최종적인 알고리즘 수행시간은 DP테이블의 셀 갯수 (N+1)^2 * 점화식 계산시간 NlogN이므로 총 시간복잡도는 O(N^3 * logN)입니다.
